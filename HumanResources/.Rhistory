cluster$betweenss
cluster$totss
cluster$centers
cluster$cluster
m = kmeans(iris[1:4],center=3)
m$cluster
table(iris$Species,m$cluster)
m = kmeans(iris[1:4],center=3)
m$cluster
table(iris$Species,m$cluster)
m = kmeans(iris[1:4],center=3)
m$cluster
table(iris$Species,m$cluster)
library(e1071)
modelo = cmeans(iris[1:4],center=3)
modelo
table(iris$Species,modelo$cluster)
modelo$size
modelo$membership
install.packages("cluster",dependencies = T)
library(cluster)
library(cluster)
plot(m)
c = pam(iris[1:4],k=3)
plot(c)
c$clustering
c$medoids
c$objective
c
table(iris$Species,c$cluster)
library(arules)
library(arules)
transacoes = read.transactions(file.choose(),format="basket",sep=",")
my = iris
my
my - cbind(my,my$Species == 'versicolor')
my = cbind(my,my$Species == 'versicolor')
my = cbind(my,my$Species == 'virginica')
my = cbind(my,my$Species == 'setosa')
summary(my)
my = iris
my
my = cbind(my,my$Species == 'setosa')
my = cbind(my,my$Species == 'versicolor')
my = cbind(my,my$Species == 'virginica')
summary(my)
names(my)[6] = 'setosa'
names(my)[6] = 'versicolor'
names(my)[6] = 'virginica'
summary(my)
names(my)[6] = 'setosa'
names(my)[7] = 'versicolor'
names(my)[8] = 'virginica'
my
q()
my = iris
my
my = cbind(my,my$Species == 'setosa')
my = cbind(my,my$Species == 'versicolor')
my = cbind(my,my$Species == 'virginica')
summary(my)
names(my)[6] = 'setosa'
names(my)[7] = 'versicolor'
names(my)[8] = 'virginica'
library(nouralnet)
library(neuralnet)
modelo = neuralnet(setosa + versicolor + virginica ~ Sepal.Length + Sepal.Width + Petal.Length + Petal.Width, my, hidden=c(5,4))
plot(modelo)
sample(my,120)
amostra = sample(2,150,replace=T,prob=c(0.7,0.3))
amostra
myTreino = my[amostra==1,]
myTeste = my[amostra==2,]
modelo = neuralnet(setosa + versicolor + virginica ~ Sepal.Length + Sepal.Width + Petal.Length + Petal.Width, my, hidden=c(5,4))
plot(modelo)
teste = compute(modelo, my[,])
teste = compute(modelo, my[,1:4])
teste
teste$net.result
names(teste$net.result)[,1] = 'setosa'
res = as.data.frame(teste$net.result)
names(teste$net.result)[,1] = 'setosa'
names(res)[,1] = 'setosa'
names(res)[1] = 'setosa'
res
names(res)[2] = 'versicolor'
names(res)[3] = 'virginica'
name.heda()
head(res)
res$class = (res[,1:3])[max.col(res[,1:3],ties.method = 'first')]
res
head(res)
head(res)
res$class = colnames(res[,1:3])[max.col(res[,1:3],ties.method = 'first')]
head(res)
digitos = read.csv(gzfile(file.choose()),header = F)
dim(digitos)
head(digitos)
split.screen(figs=c(2,2))
dig = t(matrix(unlist(digitos[20,])))
dig = t(matrix(unlist(digitos[20,-785]),nrow = 28,byrow = F))
dig = t(apply(dig,2,rev))
dig
screen(1)
image(dig,col=grey.colors(255))
dig = t(matrix(unlist(digitos[20,-785]),nrow = 28,byrow = F))
dig = t(apply(dig,2,rev))
image(dig,col=grey.colors(255))
dig = t(matrix(unlist(digitos[20,-785]),nrow = 28,byrow = F))
dig = t(apply(dig,2,rev))
dig
screen(2)
image(dig,col=grey.colors(255))
split.screen(figs=c(1))
split.screen(figs=c(1,1))
dig = t(matrix(unlist(digitos[20,-785]),nrow = 28,byrow = F))
dig = t(apply(dig,2,rev))
dig
screen(2)
image(dig,col=grey.colors(255))
q()
q()
digitos = read.csv(gzfile(file.choose()),header = F)
dim(digitos)
head(digitos)
dfasf
dfasf
d
asdfd
as
f
dig = t(matrix(unlist(digitos[20,-785]),nrow = 28,byrow = F))
dig = t(apply(dig,2,rev))
dig
screen(2)
image(dig,col=grey.colors(255))
digitos = read.csv(gzfile(file.choose()),header = F)
base = iris
base.head()
base
cbind(base,iris.Species == 'setosa')
cbind(base,iris.Species == 'bersicolor')
cbind(base,iris.Species == 'virginica')
cbind(base,base.Species == 'setosa')
base['Sepal.Length']
cbind(base,base['Species'] == 'setosa')
cbind(base,iris.['Species'] == 'bersicolor')
cbind(base,iris.['Species'] == 'virginica')
cbind(base,base.['Species'] == 'versicolor')
cbind(base,base['Species'] == 'versicolor')
cbind(base,base['Species'] == 'virginica')
base[:,6]=cbind(base,base['Species'] == 'setosa')
base[6]=cbind(base,base['Species'] == 'setosa')
base=cbind(base,base['Species'] == 'setosa')
base=cbind(base,base['Species'] == 'versicolor')
base=cbind(base,base['Species'] == 'virginica')
base
base = names(base)[7] = 'setosa'
base = names(base)[8] = 'versicolor'
base = names(base)[9] = 'virginica'
base
base = iris
base['Sepal.Length']
base=cbind(base,base['Species'] == 'setosa')
base=cbind(base,base['Species'] == 'versicolor')
base=cbind(base,base['Species'] == 'virginica')
base
names(base)[7] = 'setosa'
names(base)[8] = 'versicolor'
names(base)[9] = 'virginica'
names(base)[6] = 'setosa'
names(base)[7] = 'versicolor'
names(base)[8] = 'virginica'
base
library(neuralnet)
modelo = neuralnet(base[6]+base[7]+base[8] ~ base[1]+base[2]+base[3]+base[4],base,hidden=c(5,4))
modelo = neuralnet(setosa+versicolor+virginica ~ base[1]+base[2]+base[3]+base[4],base,hidden=c(5,4))
modelo = neuralnet(setosa+versicolor+virginica ~ Sepal.Length+Sepal.Width+Petal.Length+Petal.Width,base,hidden=c(5,4))
plot(modelo)
library(h20)
h20.init()
V(grafo2)$Peso = c(40,20,10) #cria um atributo
library(igraph)
grafo1 = graph(edges=c(1,2,2,3,3,4,4,1),directed=F,n=6,isolates=c(7)) #cria o grafo
#onde o edges é a arestas, as quais sao duplas dos elementos do vector
#directed por padrao é T
#n diz a qtd de vert, se n existir aresta, ele cria o resto isolado
#em vez de numero, pode ser strings (ai ja nomeia)
#isolates define quais vert vao estar isolados
plot(grafo1) #plota o grafo
grafo2 = graph_from_literal('A'-+'B','B'-+'C') #outra maneira de criar grafo
grafo3 = graph_from_literal(1-2,2-3)
#o sinal de + diz q a aresta vai para aquela direçao, sem o + ele fica n direcionado
plot(grafo2)
grafo2[] #tras a matriz de adjacencia, podendo fazer slice cm o [
V(grafo2)$name #ver os nomes dos vert
E(grafo2)$name #ver os nomes das arestas
V(grafo2)$Peso = c(40,20,10) #cria um atributo
grafo2
vertex_attr(grafo2)
E(grafo2)@Tipo = c('Neg','Pos','Pos')
E(grafo2)$Tipo = c('Neg','Pos','Pos')
E(grafo2)$Tipo = c('Neg','Pos')
edge_attr(grafo2) #ve os atributos dos vert
grafo2
V(grafo2)$type = 'letras' #define os tipos dos vert (padrao)
grafo2
E(grafo2)$weight = c(1,2) #define os weight das arestas (padrao)
V(grafo2)$type = 'letras' #define os tipos dos vert (padrao)
grafo2
library(igraph)
grafo1 = graph(edges=c(1,2,2,3,3,4,4,1),directed=F,n=6,isolates=c(7)) #cria o grafo
#onde o edges é a arestas, as quais sao duplas dos elementos do vector
#directed por padrao é T
#n diz a qtd de vert, se n existir aresta, ele cria o resto isolado
#em vez de numero, pode ser strings (ai ja nomeia)
#isolates define quais vert vao estar isolados
plot(grafo1) #plota o grafo
grafo2 = graph_from_literal('A'-+'B','B'-+'C') #outra maneira de criar grafo
grafo3 = graph_from_literal(1-2,2-3)
#o sinal de + diz q a aresta vai para aquela direçao, sem o + ele fica n direcionado
plot(grafo2)
grafo2[] #tras a matriz de adjacencia, podendo fazer slice cm o [
V(grafo2)$name #ver os nomes dos vert (esse e padrao)
E(grafo2)$name #ver os nomes das arestas
V(grafo2)$Peso = c(40,20,10) #cria um atributo para os vert
E(grafo2)$Tipo = c('Neg','Pos') #cria um atributo para as arestas
vertex_attr(grafo2) #ve os atributos dos vert
edge_attr(grafo2) #ve os atributos dos vert
E(grafo2)$weight = c(1,2) #define os weight das arestas (padrao)
V(grafo2)$type = 'letras' #define os tipos dos vert (padrao)
#IMPRESSÃO
plot(grafo2,vertex.size=vertex_attr(grafo))
#IMPRESSÃO
plot(grafo2,vertex.size=vertex_attr(grafo2))
#IMPRESSÃO
plot(grafo2,vertex.size=vertex_attr(grafo2)$Peso)
V(grafo2)$Cor = c('Blue','Red','Green') #cria um atributo para as arestas
#IMPRESSÃO
plot(grafo2,vertex.size=vertex_attr(grafo2)$Peso,edge.width=edege_attr(grafo2)$weight, vertex.color=vertex_attr(grafo2)$Cor)
#IMPRESSÃO
plot(grafo2,vertex.size=vertex_attr(grafo2)$Peso,edge.width=edge_attr(grafo2)$weight, vertex.color=vertex_attr(grafo2)$Cor)
#IMPRESSÃO
plot(grafo2,vertex.size=vertex_attr(grafo2)$Peso,
edge.width=edge_attr(grafo2)$weight,
vertex.color=vertex_attr(grafo2)$Cor)
#IMPRESSÃO
plot(grafo2,vertex.size=vertex_attr(grafo2)$Peso,
edge.width=edge_attr(grafo2)$weight,
vertex.color=vertex_attr(grafo2)$Cor,
edge.curved=0.4)
#IMPRESSÃO
plot(grafo2,vertex.size=vertex_attr(grafo2)$Peso,
edge.width=edge_attr(grafo2)$weight,
vertex.color=vertex_attr(grafo2)$Cor,
edge.curved=0.4, frame=t, main="Grafo")
#IMPRESSÃO
plot(grafo2,vertex.size=vertex_attr(grafo2)$Peso,
edge.width=edge_attr(grafo2)$weight,
vertex.color=vertex_attr(grafo2)$Cor,
edge.curved=0.4, frame=T, main="Grafo")
#IMPRESSÃO
plot(grafo2,vertex.size=vertex_attr(grafo2)$Peso,
edge.width=edge_attr(grafo2)$weight,
vertex.color=vertex_attr(grafo2)$Cor,
edge.curved=0.4, frame=T, main="Grafo",
vertex.shape="square")
tkplot(grafo2)
gr = read_graph(file.choose(),format=c("graphml"))
degree(grafo2,mode='all')
degree(grafo2,mode='in')
degree(grafo2,mode='out')
neighborhood(grafo2)
neighborhood(grafo2,0,mode=c('all'))
neighborhood(grafo2,0)
neighborhood(grafo2,mode=c('all'))
dist = graph(edges = c("A","C","A","B","B","E","B","F","C","D","G","H","D","H","E","H","F","G"),directed = T)
dist = graph(edges = c("A","C","A","B","B","E","B","F","C","D","G","H","D","H","E","H","F","G"),directed = T)
plot(dist)
E(dist)$weight = c(2,1,2,1,2,1,1,3,1)
plot(dis,edge.label=E(dist)$weight)
plot(dist,edge.label=E(dist)$weight)
distances(dist,V(dist)$name=="A",V(dist)$name=="H")
distances(dist,"A","H")
cam = shotest_paths(dist,"A","H")
cam = shortest_paths(dist,"A","H")
cam
cam = shortest_paths(dist,"A","H",output=c("both"))
cam
cam$vpath
cam$epath
# Configurando o diretório de trabalho
# Coloque entre aspas o diretório de trabalho que você está usando no seu computador
# Não use diretórios com espaço no nome
setwd("C:/FCD/BigDataRAzure/Cap03")
vec1 <- c(1001, 1002, 1003, 1004, 1005)
vec2 <- c(0, 1, 1, 0, 2)
vec3 <- c('Verde','Laranja','Azul','Laranja','Verde')
# Unindo os vetores em um dataframe
df <- data.frame(vec1, vec2, vec3)
df
# Verificando que o R categorizou a última coluna como fator
str(df)
# Verificando os níveis do fator. Perceba que os níveis estão categorizados em ordem alfabética
levels(df$vec3)
# Criando uma outra coluna e atribuindo labels
df$cat1 <- factor(df$vec3, labels = c("cor2", "cor1", "cor3"))
df
# Internamente, os fatores são registrados como inteiros, mas a ordenação segue a ordem alfabética
# das strings
str(df)
# Veja como foi feita a atribuição:
# Azul = cor2
# Laranja = cor1
# Verde = cor3
# Ou seja, os vetores com os labels, seguiram a ordem alfabética dos níveis classificados pelo R
# Criando uma outra coluna e atribuindo labels
# Ao aplicarmos a função factor() a coluna vec2, internamente o R classificou em ordem alfabética
# e quando atribuímos os labels, foi feita a associação.
df$cat2 <- factor(df$vec2, labels = c("Divorciado", "Casado", "Solteiro"))
df
str(df)
levels(df$cat2)
vec1 <- c(1001, 1002, 1003, 1004, 1005)
vec2 <- c(2, 1, 1, 0, 2)
vec3 <- c('Verde','Laranja','Azul','Laranja','Verde')
# Unindo os vetores em um dataframe
df <- data.frame(vec1, vec2, vec3)
df
# Verificando que o R categorizou a última coluna como fator
str(df)
# Verificando os níveis do fator. Perceba que os níveis estão categorizados em ordem alfabética
levels(df$vec3)
# Criando uma outra coluna e atribuindo labels
df$cat1 <- factor(df$vec3, labels = c("cor2", "cor1", "cor3"))
df
# Internamente, os fatores são registrados como inteiros, mas a ordenação segue a ordem alfabética
# das strings
str(df)
df$cat2 <- factor(df$vec2, labels = c("Divorciado", "Casado", "Solteiro"))
df
str(df)
levels(df$cat2)
library(xlsx)
install.packages("xlsx")
View(base)
pwd()
library(readr)
library(dplyr)
df <- read.csv('/home/salomao/Desktop/Lampejjo/instagram/username_followers.csv')
View(df)
View(df)
df %>%
select(*) %>%
filter('nutri' %in% username)
df %>%
select(*) %>%
filter('nutri' %in% df$username)
df %>%
select(*)
df %>%
filter('nutri' %in% df$username)
filter(df,'nutri' %in% username)
library(caret)
library(ggplot2)
library(gridExtra)
library(data.table)
library(car)
library(caTools)
library(corrplot)
library(rpart)
library(rpart.plot)
# Carregando o dataset
dados_rh <- fread('dados/dataset.csv')
dim(dados_rh)
View(dados_rh)
str(dados_rh)
summary(dados_rh)
getwd()
setwd("~/Desktop/DSProject/RH/")
getwd()
dados_rh <- fread('dados/dataset.csv')
dim(dados_rh)
View(dados_rh)
str(dados_rh)
summary(dados_rh)
dados_rh$Attrition                <- as.factor(dados_rh$Attrition)
dados_rh$BusinessTravel           <- as.factor(dados_rh$BusinessTravel)
dados_rh$Department               <- as.factor(dados_rh$Department)
dados_rh$Education                <- as.factor(dados_rh$Education)
dados_rh$EducationField           <- as.factor(dados_rh$EducationField)
dados_rh$'Employee Source'        <- as.factor(dados_rh$'Employee Source')
dados_rh$EnvironmentSatisfaction  <- as.factor(dados_rh$Enviroatisfaction)
dados_rh$Gender                   <- as.factor(dados_rh$Gender)
dados_rh$JobInvolvement           <- as.factor(dados_rh$JobInvolvement)
dados_rh$JobLevel                 <- as.factor(dados_rh$JobLevel)
dados_rh$JobRole                  <- as.factor(dados_rh$JobRole)
dados_rh$JobSatisfaction          <- as.factor(dados_rh$JobSatisfaction)
dados_rh$MaritalStatus            <- as.factor(dados_rh$MaritalStatus)
dados_rh$OverTime                 <- as.factor(dados_rh$OverTime)
dados_rh$PerformanceRating        <- as.factor(dados_rh$PerformanceRating)
dados_rh$RelationshipSatisfaction <- as.factor(dados_rh$RelationshipSatisfaction)
dados_rh$StockOptionLevel         <- as.factor(dados_rh$StockOptionLevel)
dados_rh$WorkLifeBalance          <- as.factor(dados_rh$WorkLifeBalance)
str(dados_rh)
dados_rh$DistanceFromHome  <- as.integer(dados_rh$DistanceFromHome)
dados_rh$MonthlyIncome     <- as.integer(dados_rh$MonthlyIncome)
dados_rh$PercentSalaryHike <- as.integer(dados_rh$PercentSalaryHike)
# Drop dos níveis de fatores com 0 count
dados <- droplevels(dados_rh)
str(dados_rh)
summary(dados_rh)
dados_rh$PriorYearsOfExperience <- dados_rh$TotalWorkingYears - dados_rh$YearsAtCompany
dados_rh$AverageTenure <- dados_rh$PriorYearsOfExperience / dados_rh$NumCompaniesWorked
summary(dados_rh$AverageTenure)
dados_rh$AverageTenure[!is.finite(dados_rh$AverageTenure)] <- 0
summary(dados_rh$AverageTenure)
# o funcionário foi desligado da empresa.
dados_rh_1 <- dados_rh[dados_rh$Attrition != 'Termination']
dados_rh_1 <- droplevels(dados_rh_1)
dim(dados_rh_1)
summary(dados_rh_1)
dados_rh_2 <- dados_rh[dados_rh$Attrition != 'Voluntary Resignation']
dados_rh_2 <-droplevels(dados_rh_2)
dim(dados_rh_2)
summary(dados_rh_2)
ggplot(dados_rh) + geom_bar(aes(x = Gender))
ggplot(dados_rh) + geom_density(aes(x = Age))
ggplot(dados_rh) + geom_bar(aes(x = Attrition))
ggplot(dados_rh) + geom_density(aes(x = Age))
ggplot(dados_rh) + geom_bar(aes(x = Education)) + facet_grid(~EducationField)
ggplot(dados_rh) + geom_bar(aes(x = Education))
ggplot(dados_rh) + geom_bar(aes(x = Education)) + facet_grid(~EducationField)
p.TotalWorkingYears       <- ggplot(dados_rh) + geom_density(aes(TotalWorkingYears))
p.YearsAtCompany          <- ggplot(dados_rh) + geom_density(aes(YearsAtCompany))
p.YearsSinceLastPromotion <- ggplot(dados_rh) + geom_density(aes(YearsSinceLastPromotion))
p.YearsWithCurrManager    <- ggplot(dados_rh) + geom_density(aes(YearsWithCurrManager))
p.YearsInCurrentRole      <- ggplot(dados_rh) + geom_density(aes(YearsInCurrentRole))
p.PriorYearsOfExperience  <- ggplot(dados_rh) + geom_density(aes(PriorYearsOfExperience))
# Organiza no grid
grid.arrange(p.TotalWorkingYears,
p.YearsAtCompany,
p.YearsSinceLastPromotion,
p.YearsWithCurrManager,
p.YearsInCurrentRole,
p.PriorYearsOfExperience,
nrow = 2,
ncol = 3)
length(which(dados_rh$PriorYearsOfExperience < 1)) / length(dados_rh$PriorYearsOfExperience)
length(which(dados_rh$PriorYearsOfExperience < 3)) / length(dados_rh$PriorYearsOfExperience)
length(which(dados_rh$PriorYearsOfExperience < 5)) / length(dados_rh$PriorYearsOfExperience)
length(which(dados_rh$PriorYearsOfExperience < 7)) / length(dados_rh$PriorYearsOfExperience)
length(which(dados_rh$PriorYearsOfExperience < 10)) / length(dados_rh$PriorYearsOfExperience)
which(dados_rh$PriorYearsOfExperience < 10)
ggplot(data = subset(dados_rh, !is.na(JobRole))) + geom_boxplot(aes(JobRole, MonthlyIncome)) +
ggtitle("Salário Mensal Por Função")
# Plots de análise multivariada para variáveis normalmente usadas durante o processo de contratação
ggplot(data = dados_rh_1) +
geom_bar(aes(x = Education , fill = Attrition), position = 'fill') +
facet_grid(.~Department)
ggplot(data = dados_rh_1) +
geom_bar(aes(x = Education , fill = Attrition), position = 'fill') +
facet_grid(.~JobRole)
ggplot(data = dados_rh_1) +
geom_bar(aes(x = EducationField , fill = Attrition), position = 'fill') +
facet_grid(.~JobRole) +
theme(axis.text.x = element_text(angle = -90, hjust = 0))
ggplot(dados_rh_1) + geom_bar(aes(x = Age, fill = Attrition), position = 'fill')
ggplot(data = subset(dados_rh, !is.na(JobRole))) + geom_boxplot(aes(JobRole, Age)) +
ggtitle("Idade Por Função")
# Verificando a diferença salarial entre homens e mulheres.
ggplot(data = subset(dados_rh, !is.na(Gender)), aes(Gender, MonthlyIncome, fill = Gender)) +
geom_boxplot() +
theme(legend.position = "none", plot.title = element_text(hjust = 0.5, size = 10)) +
labs(x = "Gender", y = "Monthly Income", title = "Salário Mensal Entre Gêneros") +
coord_flip()
cor(dados_rh$TotalWorkingYears, dados_rh$YearsAtCompany,          use = "complete.obs")
ggplot(data = dados_rh_1) +
geom_bar(aes(x = Education , fill = Attrition), position = 'fill') +
facet_grid(.~Department)
modelo_v1 <- glm(Attrition ~ Age + Department + DistanceFromHome + `Employee Source` +
JobRole + MaritalStatus + AverageTenure + PriorYearsOfExperience + Gender +
Education + EducationField,
family = binomial,
data = dados_rh)
summary(modelo_v1)
vif(modelo_v1)
?vif
??vif
index_treino <- sample.split(Y = dados_rh_1$Attrition, SplitRatio = 0.7)
dados_rh_1_treino <- subset(dados_rh_1, train = T)
dados_rh_1_teste <- subset(dados_rh_1, train = F)
# Segunda versão do modelo com dados de treino
modelo_v2 <- glm(Attrition ~ Age + Department + DistanceFromHome + `Employee Source` +
JobRole + MaritalStatus + AverageTenure + PriorYearsOfExperience + Gender +
Education + EducationField,
family = binomial,
data = dados_rh_1_treino)
threshold <- 0.5
previsoes_v2 <- predict(modelo_v2, type = 'response', newdata = dados_rh_1_teste)
previsoes_finais_v2 <- ifelse(previsoes_v2 > threshold, 'Voluntary Resignation', 'Current employee')
table(dados_rh_1_teste$Attrition, previsoes_finais_v2)
threshold <- 0.5
previsoes_v2 <- predict(modelo_v2, type = 'response', newdata = dados_rh_1_teste)
previsoes_finais_v2 <- ifelse(previsoes_v2 > threshold, 'Voluntary Resignation', 'Current employee')
table(dados_rh_1_teste$Attrition, previsoes_finais_v2)
# Quarta versão do modelo com dados de treino e sem variáveis de educação e genero
modelo_v4 <- glm(Attrition ~ Age + Department + DistanceFromHome + `Employee Source` +
JobRole + MaritalStatus + AverageTenure + PriorYearsOfExperience,
family = binomial,
data = dados_rh_1_treino)
summary(modelo_v4)
